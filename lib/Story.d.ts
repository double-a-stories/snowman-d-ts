declare let story: Story;

declare class Story {
  constructor(dataEl: any);

  /** The name of the story. */
  readonly name: string;
  /** The ID of the first passage to be displayed. */
  readonly startPassage: number;
  /** The program that created this story. */
  readonly creator: string;
  /** The version of the program used to create this story. */
  creatorVersion: string;
  /**
   * An array of passage IDs, one for each passage viewed during the current
   * session.
   */
  history: any[];
  /**
   * An object that stores data that persists across a single user session. Any
   * other variables will not survive the user pressing back or forward.
   */
  state: any;
  /**
   * The name of the last checkpoint set. If none has been set, this is an empty
   * string.
   */
  readonly checkpointName: string;
  /**
   * If set to true, then any JavaScript errors are ignored -- normally, play
   * would end with a message shown to the user.
   */
  ignoreErrors: boolean;
  /**
   * The message shown to users when there is an error and ignoreErrors is not
   * true.
   */
  errorMessage: string;
  /**
   * Mainly for internal use, this records whether the current passage contains
   * a checkpoint.
   */
  private atCheckpoint: boolean;
  /** An array of all passages, indexed by ID. */
  passages: Passage[];
  /** An array of user-specific scripts to run when the story is begun. */
  userScripts: string[];
  /**
   * An array of user-specific style declarations to add when the story is
   * begun.
   */
  userStyles: string[];
  /**
   * Begins playing this story.
   *
   * @param {Element} el Element to show content in
   */
  start(el: Element): void;
  $el: any;
  $passageEl: any;
  /**
   * Returns the Passage object corresponding to either an ID or name. If none
   * exists, then it returns null.
   */
  passage(idOrName: PassageID): Passage | null;
  /**
   * Displays a passage on the page, replacing the current one. If there is no
   * passage by the name or ID passed, an exception is raised.
   *
   * Calling this immediately inside a passage (i.e. in its source code) will
   * _not_ display the other passage. Use Story.render() instead.
   *
   * @param idOrName ID or name of the passage
   * @param noHistory If true, then this will not be recorded in the story
   *   history
   */
  show(idOrName: string, noHistory?: boolean): void;
  /**
   * Returns the HTML source for a passage. This is most often used when
   * embedding one passage inside another. In this instance, make sure to use
   * <%= %> instead of <%- %> to avoid incorrectly encoding HTML entities.
   *
   * @param idOrName {String or Number} ID or name of the passage
   * @returns HTML source code
   */
  render(idOrName: string): string;
  /**
   * Records that the current story state should be added to the browser
   * history. Actually saving it occurs once the user navigates to another
   * passage -- otherwise, clicking the back button would cause the story to
   * show the same passage twice. Remember, only variables set on this story's
   * state variable are stored in the browser history.
   *
   * @param name Checkpoint name, appears in history, optional
   */
  checkpoint(name: string): void;
  /** Sets the URL's hash property to the hash value created by saveHash(). */
  save(hash: any): void;
  /** Returns LZString + compressBase64 Hash. */
  saveHash(): any;
  /**
   * Tries to restore the story state from a hash value generated by saveHash().
   *
   * @returns If the restore succeeded
   */
  restore(hash: string): boolean;
}
